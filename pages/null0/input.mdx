import { Callout, Tab, Tabs } from 'nextra-theme-docs'
import Cart from '@/components/Cart.jsx'

<Callout emoji="ðŸ•¹">
The idea with input is that all is a "button" and buttons can be up or down. <br/>
All input is routed through a couple of functions, so you can respond to it.
</Callout>

See [here](https://docs.libretro.com/guides/input-and-controls/) for info on how RetroArch maps keys to the virtual gamepad.

Here is an example, click to focus for input:

<Cart cart='/input.null0' />

Source: [input](https://github.com/notnullgames/null0/tree/main/src/carts/input)


The null0 zip-file looks like this:
```
â”œâ”€â”€ assets
â”‚ â”œâ”€â”€ a.png
â”‚ â”œâ”€â”€ b.png
â”‚ â”œâ”€â”€ bg.png
â”‚ â”œâ”€â”€ down.png
â”‚ â”œâ”€â”€ l1.png
â”‚ â”œâ”€â”€ left.png
â”‚ â”œâ”€â”€ r1.png
â”‚ â”œâ”€â”€ right.png
â”‚ â”œâ”€â”€ select.png
â”‚ â”œâ”€â”€ start.png
â”‚ â”œâ”€â”€ up.png
â”‚ â”œâ”€â”€ x.png
â”‚ â””â”€â”€ y.png
â””â”€â”€ main.wasm
```

### Button

This is an enum that represents the directional or button that was pressed/released.

```ts
BUTTON_B
BUTTON_Y
BUTTON_SELECT
BUTTON_START
BUTTON_UP
BUTTON_DOWN
BUTTON_LEFT
BUTTON_RIGHT
BUTTON_A
BUTTON_X
BUTTON_L
BUTTON_R
BUTTON_L2
BUTTON_R2
BUTTON_L3
BUTTON_R3
```


### buttonDown()

This is called whenever a button or directional is pressed on the virtual gamepad.

<Tabs items={['Nim', 'Assemblyscript', 'C/C++']}>
<Tab>
```nim
proc buttonDown(button: Button) {.null0.} =
  # handle your input here
  if button == BUTTON_A:
    echo "A pressed!"
```
</Tab>

<Tab>
```ts
export function buttonDown(button: Button) {
  // handle your input here
  if (button == BUTTON_A) {
    trace("A pressed!")
  }
}
```
</Tab>

<Tab>
```c
NULL0_EXPORT("buttonDown")
void buttonDown(Button button) {
  // handle your input here
  if (button == BUTTON_A) {
    log("A pressed!");
  }
}
```
</Tab>
</Tabs>


### buttonUp()

This is called whenever a button or directional is un-pressed on the virtual gamepad.

<Tabs items={['Nim', 'Assemblyscript', 'C/C++']}>
<Tab>
```nim
proc buttonUp(button: Button) {.null0.} =
  # handle your input here
  if button == BUTTON_A:
    echo "A released!"
```
</Tab>

<Tab>
```ts
export function buttonUp(button: Button) {
  // handle your input here
  if (button == BUTTON_A) {
    trace("A released!")
  }
}
```
</Tab>

<Tab>
```c
NULL0_EXPORT("buttonUp")
void buttonUp(Button button) {
  // handle your input here
  if (button == BUTTON_A) {
    log("A released!");
  }
}
```
</Tab>
</Tabs>

### no callbacks

Using the above callbacks, you can quickly get "mapped" input, which means that the up-arrow on the keyboard is the same as up on gamepad 1 or 2. If you want finer-grained control of things, you can use direct lookups of state for mouse/gamepad/keyboard.

- You can drill into specific inputs (if you care about keyboard vs gamepad, for example)
- You can use `pressed`/`released` functions to trigger actions, and it will debounce and only fire once.
- You can use `down`/`up` to get the current state of it

```nim
# has the key been pressed? (tracks unpress/read correctly)
proc key_pressed(key:Key): boolean

# is the key currently down?
proc key_down(key:Key): boolean

# is the key released? (tracks press/read correctly)
proc key_released(key:Key): boolean

# is the key currently up?
proc key_up(key:Key): boolean

# has the button been pressed? (tracks unpress/read correctly)
proc gamepad_button_pressed(gamepad:i32, key:GamepadButton): boolean

# is the button currently down?
proc gamepad_button_down(i32 gamepad, GamepadButton key): boolean

# is the button released? (tracks press/read correctly)
proc gamepad_button_released(i32 gamepad, GamepadButton key): boolean

# is the button currently up?
proc gamepad_button_up(i32 gamepad, GamepadButton key): boolean

# current position of mouse
proc mouse_position(): Vector*

# has the button been pressed? (tracks unpress/read correctly)
proc mouse_button_pressed(MouseButton button): boolean

# is the button currently down?
proc mouse_button_down(MouseButton button): boolean

# is the button released? (tracks press/read correctly)
proc mouse_button_released(MouseButton button): boolean

# is the button currently up?
proc mouse_button_up(MouseButton button): boolean
```

